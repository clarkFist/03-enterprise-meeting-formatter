#!/usr/bin/env python3
"""
VCUé¡¹ç›®ä¼šè®®å›¾ç‰‡OCRæå–å™¨
ä½¿ç”¨Claude Vision APIä»ä¼šè®®å›¾ç‰‡ä¸­æå–å‚ä¼šäººå‘˜ä¿¡æ¯å¹¶è‡ªåŠ¨ç”Ÿæˆä¼šè®®çºªè¦
"""

import os
import sys
import json
import yaml
import base64
import argparse
import subprocess
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional

# å°è¯•å¯¼å…¥anthropicï¼Œå¦‚æœæœªå®‰è£…åˆ™æç¤º
try:
    import anthropic
except ImportError:
    print("âŒ é”™è¯¯: éœ€è¦å®‰è£… anthropic åº“")
    print("   å®‰è£…å‘½ä»¤: pip install anthropic")
    sys.exit(1)


class MeetingImageExtractor:
    """ä¼šè®®å›¾ç‰‡OCRæå–å™¨"""

    def __init__(self, skill_dir=None):
        """åˆå§‹åŒ–æå–å™¨

        Args:
            skill_dir: SkillåŒ…æ ¹ç›®å½•ï¼Œé»˜è®¤ä¸ºè„šæœ¬æ‰€åœ¨ç›®å½•çš„çˆ¶ç›®å½•
        """
        if skill_dir is None:
            skill_dir = Path(__file__).parent.parent
        else:
            skill_dir = Path(skill_dir)

        self.skill_dir = skill_dir
        self.data_dir = skill_dir / "data"
        self.scripts_dir = skill_dir / "scripts"

        # åŠ è½½å‚ä¼šäººå‘˜æ•°æ®åº“
        self.attendees_db = self._load_attendees_db()

        # åˆå§‹åŒ–Claudeå®¢æˆ·ç«¯
        api_key = os.environ.get("ANTHROPIC_API_KEY")
        if not api_key:
            raise ValueError(
                "âŒ é”™è¯¯: æœªè®¾ç½® ANTHROPIC_API_KEY ç¯å¢ƒå˜é‡\n"
                "   è®¾ç½®æ–¹æ³•: export ANTHROPIC_API_KEY='your-api-key'"
            )

        self.client = anthropic.Anthropic(api_key=api_key)

    def _load_attendees_db(self) -> Dict:
        """åŠ è½½å‚ä¼šäººå‘˜æ•°æ®åº“"""
        attendees_file = self.data_dir / "attendees.yaml"
        if not attendees_file.exists():
            raise FileNotFoundError(f"å‚ä¼šäººå‘˜æ•°æ®åº“ä¸å­˜åœ¨: {attendees_file}")

        with open(attendees_file, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)

    def _encode_image(self, image_path: str) -> tuple[str, str]:
        """å°†å›¾ç‰‡ç¼–ç ä¸ºbase64

        Args:
            image_path: å›¾ç‰‡æ–‡ä»¶è·¯å¾„

        Returns:
            tuple: (base64ç¼–ç çš„å›¾ç‰‡æ•°æ®, åª’ä½“ç±»å‹)
        """
        image_path = Path(image_path)
        if not image_path.exists():
            raise FileNotFoundError(f"å›¾ç‰‡æ–‡ä»¶ä¸å­˜åœ¨: {image_path}")

        # æ ¹æ®æ–‡ä»¶æ‰©å±•åç¡®å®šåª’ä½“ç±»å‹
        ext = image_path.suffix.lower()
        media_type_map = {
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.png': 'image/png',
            '.gif': 'image/gif',
            '.webp': 'image/webp'
        }
        media_type = media_type_map.get(ext, 'image/jpeg')

        with open(image_path, 'rb') as f:
            image_data = base64.standard_b64encode(f.read()).decode('utf-8')

        return image_data, media_type

    def extract_from_image(self, image_path: str) -> Dict:
        """ä½¿ç”¨Claude Vision APIä»å›¾ç‰‡ä¸­æå–ä¼šè®®ä¿¡æ¯

        Args:
            image_path: å›¾ç‰‡æ–‡ä»¶è·¯å¾„

        Returns:
            dict: æå–çš„ä¼šè®®ä¿¡æ¯ï¼ŒåŒ…å«å‚ä¼šäººå‘˜ã€ä¼šè®®æ—¶é—´ç­‰
        """
        print(f"ğŸ” åˆ†æå›¾ç‰‡: {image_path}")

        # ç¼–ç å›¾ç‰‡
        image_data, media_type = self._encode_image(image_path)

        # æ„å»ºæç¤ºè¯
        prompt = """è¯·ä»”ç»†åˆ†æè¿™å¼ ä¼šè®®ç›¸å…³çš„å›¾ç‰‡ï¼Œæå–ä»¥ä¸‹ä¿¡æ¯ï¼š

1. **å‚ä¼šäººå‘˜åˆ—è¡¨**ï¼šæå–æ‰€æœ‰å‚ä¼šäººå‘˜çš„ä¿¡æ¯
   - å§“åï¼ˆå¿…é¡»ï¼‰
   - å·¥å·ï¼ˆå¦‚æœæœ‰ï¼‰
   - è§’è‰²/èŒä½ï¼ˆå¦‚æœæœ‰ï¼‰
   - è´Ÿè´£æ¨¡å—ï¼ˆå¦‚æœæœ‰ï¼‰
   - å‡ºå¸­çŠ¶æ€ï¼ˆå¦‚æœæœ‰æ ‡æ³¨ï¼‰

2. **ä¼šè®®åŸºæœ¬ä¿¡æ¯**ï¼ˆå¦‚æœå›¾ç‰‡ä¸­åŒ…å«ï¼‰ï¼š
   - ä¼šè®®æ—¶é—´
   - ä¼šè®®åœ°ç‚¹
   - ä¼šè®®ä¸»æŒäºº
   - è®°å½•äººå‘˜
   - ä¼šè®®æ€§è´¨

3. **æ¨¡å—è¿›å±•ä¿¡æ¯**ï¼ˆå¦‚æœå›¾ç‰‡ä¸­åŒ…å«ï¼‰ï¼š
   - æ¨¡å—åç§°
   - è´Ÿè´£äºº
   - è¿›å±•çŠ¶æ€
   - å­˜åœ¨çš„é—®é¢˜
   - åç»­è®¡åˆ’

è¯·ä»¥JSONæ ¼å¼è¿”å›ç»“æœï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
```json
{
  "meeting_info": {
    "meeting_time": "YYYY-MM-DD HH:MM-HH:MM",
    "meeting_location": "ä¼šè®®åœ°ç‚¹",
    "meeting_host": "ä¸»æŒäºº",
    "recorder": "è®°å½•äººï¼ˆå·¥å·ï¼‰",
    "meeting_nature": "ä¼šè®®æ€§è´¨",
    "company_name": "CASCO SIGNAL"
  },
  "attendees": [
    {
      "name": "å§“å",
      "employee_id": "å·¥å·",
      "role": "è§’è‰²",
      "module": "è´Ÿè´£æ¨¡å—",
      "present": true
    }
  ],
  "modules": [
    {
      "name": "æ¨¡å—åç§°",
      "owner": "è´Ÿè´£äºº",
      "status": "è¿›å±•çŠ¶æ€",
      "progress": ["è¿›å±•å†…å®¹1", "è¿›å±•å†…å®¹2"],
      "issues": ["é—®é¢˜1", "é—®é¢˜2"],
      "plans": ["è®¡åˆ’1", "è®¡åˆ’2"]
    }
  ]
}
```

æ³¨æ„ï¼š
1. å¦‚æœæŸäº›ä¿¡æ¯åœ¨å›¾ç‰‡ä¸­ä¸å­˜åœ¨ï¼Œå¯ä»¥çœç•¥å¯¹åº”å­—æ®µæˆ–è¿”å›ç©ºå€¼
2. å·¥å·å¿…é¡»æ˜¯çº¯æ•°å­—ï¼Œä¸è¦åŒ…å«å…¶ä»–å­—ç¬¦
3. å§“åå¿…é¡»æ˜¯ä¸­æ–‡å…¨å
4. ç¡®ä¿JSONæ ¼å¼æ­£ç¡®ï¼Œå¯ä»¥è¢«è§£æ"""

        # è°ƒç”¨Claude Vision API
        try:
            message = self.client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=4096,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "image",
                                "source": {
                                    "type": "base64",
                                    "media_type": media_type,
                                    "data": image_data,
                                },
                            },
                            {
                                "type": "text",
                                "text": prompt
                            }
                        ],
                    }
                ],
            )

            # è§£æå“åº”
            response_text = message.content[0].text

            # å°è¯•ä»å“åº”ä¸­æå–JSON
            # Claudeå¯èƒ½ä¼šåœ¨JSONå‰åæ·»åŠ è¯´æ˜æ–‡å­—ï¼Œéœ€è¦æå–```json```å—
            if "```json" in response_text:
                json_start = response_text.find("```json") + 7
                json_end = response_text.find("```", json_start)
                json_str = response_text[json_start:json_end].strip()
            elif "```" in response_text:
                json_start = response_text.find("```") + 3
                json_end = response_text.find("```", json_start)
                json_str = response_text[json_start:json_end].strip()
            else:
                json_str = response_text.strip()

            extracted_data = json.loads(json_str)

            print(f"âœ… æˆåŠŸæå–ä¿¡æ¯")
            print(f"   - æ‰¾åˆ° {len(extracted_data.get('attendees', []))} åå‚ä¼šäººå‘˜")
            if 'modules' in extracted_data:
                print(f"   - æ‰¾åˆ° {len(extracted_data.get('modules', []))} ä¸ªæ¨¡å—æ±‡æŠ¥")

            return extracted_data

        except json.JSONDecodeError as e:
            print(f"âŒ JSONè§£æå¤±è´¥: {e}")
            print(f"åŸå§‹å“åº”:\n{response_text}")
            raise
        except Exception as e:
            print(f"âŒ APIè°ƒç”¨å¤±è´¥: {e}")
            raise

    def match_attendees(self, extracted_attendees: List[Dict]) -> List[Dict]:
        """å°†æå–çš„å‚ä¼šäººå‘˜ä¸æ•°æ®åº“åŒ¹é…

        Args:
            extracted_attendees: ä»å›¾ç‰‡ä¸­æå–çš„å‚ä¼šäººå‘˜åˆ—è¡¨

        Returns:
            list: åŒ¹é…åçš„å®Œæ•´å‚ä¼šäººå‘˜ä¿¡æ¯
        """
        print("\nğŸ”— åŒ¹é…å‚ä¼šäººå‘˜æ•°æ®åº“...")

        matched = []
        unmatched = []

        # æ„å»ºæ•°æ®åº“ç´¢å¼•ï¼ˆæŒ‰å§“åå’Œå·¥å·ï¼‰
        db_by_name = {}
        db_by_id = {}

        for category in ['hosts', 'managers', 'engineers']:
            if category not in self.attendees_db:
                continue
            for person in self.attendees_db[category]:
                name = person.get('name', '')
                emp_id = person.get('employee_id', '')
                if name:
                    db_by_name[name] = person
                if emp_id:
                    db_by_id[emp_id] = person

        # åŒ¹é…æ¯ä¸ªæå–çš„äººå‘˜
        for extracted in extracted_attendees:
            name = extracted.get('name', '').strip()
            emp_id = extracted.get('employee_id', '').strip()

            matched_person = None

            # ä¼˜å…ˆæŒ‰å·¥å·åŒ¹é…
            if emp_id and emp_id in db_by_id:
                matched_person = db_by_id[emp_id].copy()
                print(f"  âœ“ {name} ({emp_id}) - æŒ‰å·¥å·åŒ¹é…")
            # å…¶æ¬¡æŒ‰å§“ååŒ¹é…
            elif name and name in db_by_name:
                matched_person = db_by_name[name].copy()
                print(f"  âœ“ {name} - æŒ‰å§“ååŒ¹é…")

            if matched_person:
                # æ›´æ–°å‡ºå¸­çŠ¶æ€
                matched_person['present'] = extracted.get('present', True)
                matched.append(matched_person)
            else:
                # æœªåŒ¹é…åˆ°ï¼Œè®°å½•æ–°äººå‘˜
                unmatched.append(extracted)
                print(f"  âš ï¸  {name} ({emp_id}) - æœªåœ¨æ•°æ®åº“ä¸­æ‰¾åˆ°")

        if unmatched:
            print(f"\nâš ï¸  å‘ç° {len(unmatched)} åæ–°äººå‘˜ï¼Œå°†ä½¿ç”¨æå–çš„ä¿¡æ¯")

        print(f"\nâœ… åŒ¹é…å®Œæˆ: {len(matched)} äººåŒ¹é…ï¼Œ{len(unmatched)} äººæ–°å¢")

        return matched, unmatched

    def generate_config(
        self,
        meeting_info: Dict,
        matched_attendees: List[Dict],
        unmatched_attendees: List[Dict],
        modules: Optional[List[Dict]] = None,
        output_path: Optional[str] = None
    ) -> Path:
        """ç”Ÿæˆä¼šè®®è¾“å…¥é…ç½®æ–‡ä»¶

        Args:
            meeting_info: ä¼šè®®åŸºæœ¬ä¿¡æ¯
            matched_attendees: åŒ¹é…çš„å‚ä¼šäººå‘˜
            unmatched_attendees: æœªåŒ¹é…çš„å‚ä¼šäººå‘˜
            modules: æ¨¡å—è¿›å±•ä¿¡æ¯
            output_path: è¾“å‡ºæ–‡ä»¶è·¯å¾„ï¼Œé»˜è®¤è‡ªåŠ¨ç”Ÿæˆ

        Returns:
            Path: ç”Ÿæˆçš„é…ç½®æ–‡ä»¶è·¯å¾„
        """
        print("\nğŸ“ ç”Ÿæˆé…ç½®æ–‡ä»¶...")

        # ç¡®å®šè¾“å‡ºè·¯å¾„
        if output_path is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_path = self.data_dir / f"meeting-input-{timestamp}.yaml"
        else:
            output_path = Path(output_path)

        # æŒ‰è§’è‰²åˆ†ç»„å‚ä¼šäººå‘˜
        hosts = []
        managers = []
        engineers = []

        for person in matched_attendees:
            role = person.get('role', '')
            if 'é¡¹ç›®ç»ç†' in role or 'ä¸»æŒ' in role:
                hosts.append(person)
            elif 'ç®¡ç†' in role:
                managers.append(person)
            else:
                engineers.append(person)

        # å°†æœªåŒ¹é…çš„äººå‘˜æ·»åŠ åˆ°engineers
        for person in unmatched_attendees:
            engineers.append(person)

        # æ„å»ºé…ç½®æ•°æ®
        config_data = {
            'meeting_time': meeting_info.get('meeting_time', datetime.now().strftime("%Y-%m-%d %H:%M-%H:%M")),
            'meeting_location': meeting_info.get('meeting_location', 'ä¼ä¸šå¾®ä¿¡ä¼šè®®'),
            'meeting_host': meeting_info.get('meeting_host', hosts[0]['name'] if hosts else ''),
            'recorder': meeting_info.get('recorder', ''),
            'meeting_nature': meeting_info.get('meeting_nature', 'å®šæœŸé¡¹ç›®ä¾‹ä¼š'),
            'meeting_type': 'Regular',
            'priority': 'High',
            'company_name': meeting_info.get('company_name', 'CASCO SIGNAL'),
            'attendees': {
                'hosts': hosts,
                'managers': managers,
                'engineers': engineers
            }
        }

        # æ·»åŠ æ¨¡å—ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
        if modules:
            config_data['modules'] = modules

        # å†™å…¥YAMLæ–‡ä»¶
        with open(output_path, 'w', encoding='utf-8') as f:
            yaml.dump(config_data, f, allow_unicode=True, sort_keys=False, default_flow_style=False)

        print(f"âœ… é…ç½®æ–‡ä»¶å·²ç”Ÿæˆ: {output_path}")
        print(f"   æ–‡ä»¶å¤§å°: {output_path.stat().st_size / 1024:.1f} KB")

        return output_path

    def process_image(
        self,
        image_path: str,
        generate_pdf: bool = False,
        auto_open: bool = True
    ) -> Dict:
        """å¤„ç†å›¾ç‰‡å¹¶ç”Ÿæˆä¼šè®®çºªè¦

        Args:
            image_path: å›¾ç‰‡è·¯å¾„
            generate_pdf: æ˜¯å¦è‡ªåŠ¨ç”ŸæˆPDF
            auto_open: æ˜¯å¦è‡ªåŠ¨æ‰“å¼€ç”Ÿæˆçš„æ–‡ä»¶

        Returns:
            dict: å¤„ç†ç»“æœï¼ŒåŒ…å«ç”Ÿæˆçš„æ–‡ä»¶è·¯å¾„
        """
        result = {}

        # 1. æå–ä¿¡æ¯
        extracted_data = self.extract_from_image(image_path)

        # 2. åŒ¹é…å‚ä¼šäººå‘˜
        attendees = extracted_data.get('attendees', [])
        matched, unmatched = self.match_attendees(attendees)

        # 3. ç”Ÿæˆé…ç½®æ–‡ä»¶
        meeting_info = extracted_data.get('meeting_info', {})
        modules = extracted_data.get('modules', [])

        config_path = self.generate_config(
            meeting_info=meeting_info,
            matched_attendees=matched,
            unmatched_attendees=unmatched,
            modules=modules if modules else None
        )
        result['config_path'] = str(config_path)

        # 4. ç”ŸæˆMarkdown
        print("\nğŸ“„ ç”Ÿæˆä¼šè®®çºªè¦Markdown...")
        generate_script = self.scripts_dir / "generate-meeting.py"

        try:
            subprocess.run(
                [sys.executable, str(generate_script), str(config_path)],
                check=True,
                capture_output=True,
                text=True
            )

            # è·å–ç”Ÿæˆçš„Markdownæ–‡ä»¶è·¯å¾„
            meeting_time = meeting_info.get('meeting_time', datetime.now().strftime("%Y-%m-%d"))
            date_str = meeting_time.split()[0].replace('-', '')
            md_filename = f"RB99125046å®‰å…¨è¿ç®—ä¸æ§åˆ¶å¹³å°ï¼ˆVCUï¼‰é¡¹ç›®ä¾‹ä¼šä¼šè®®çºªè¦_{date_str}.md"
            md_path = Path.cwd() / md_filename

            if md_path.exists():
                result['markdown_path'] = str(md_path)
                print(f"âœ… Markdownå·²ç”Ÿæˆ: {md_path}")

        except subprocess.CalledProcessError as e:
            print(f"âš ï¸  Markdownç”Ÿæˆå¤±è´¥: {e}")
            print(f"   é”™è¯¯è¾“å‡º: {e.stderr}")

        # 5. ç”ŸæˆPDFï¼ˆå¦‚æœéœ€è¦ï¼‰
        if generate_pdf and 'markdown_path' in result:
            print("\nğŸ“„ è½¬æ¢ä¸ºPDF...")
            # æŸ¥æ‰¾run.pyæˆ–ä½¿ç”¨md2pdfå‘½ä»¤
            run_script = Path(__file__).parent.parent.parent.parent / "run.py"

            try:
                if run_script.exists():
                    subprocess.run(
                        [sys.executable, str(run_script), result['markdown_path']],
                        check=True
                    )
                else:
                    subprocess.run(
                        ['md2pdf', result['markdown_path'], '-t', 'enterprise'],
                        check=True
                    )

                pdf_path = Path(result['markdown_path']).with_suffix('.pdf')
                if pdf_path.exists():
                    result['pdf_path'] = str(pdf_path)
                    print(f"âœ… PDFå·²ç”Ÿæˆ: {pdf_path}")

                    if auto_open:
                        print(f"ğŸ“– æ‰“å¼€PDF...")
                        subprocess.run(['open', str(pdf_path)])

            except Exception as e:
                print(f"âš ï¸  PDFç”Ÿæˆå¤±è´¥: {e}")

        return result


def main():
    """ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(
        description='VCUé¡¹ç›®ä¼šè®®å›¾ç‰‡OCRæå–å™¨ - ä»å›¾ç‰‡è‡ªåŠ¨ç”Ÿæˆä¼šè®®çºªè¦',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¤ºä¾‹:
  # æå–å›¾ç‰‡ä¿¡æ¯å¹¶ç”Ÿæˆé…ç½®æ–‡ä»¶
  %(prog)s meeting-photo.png

  # æå–å¹¶è‡ªåŠ¨ç”ŸæˆPDF
  %(prog)s meeting-photo.png --generate-pdf

  # ç”ŸæˆPDFä½†ä¸è‡ªåŠ¨æ‰“å¼€
  %(prog)s meeting-photo.png --generate-pdf --no-open

  # æŒ‡å®šè¾“å‡ºé…ç½®æ–‡ä»¶è·¯å¾„
  %(prog)s meeting-photo.png -o custom-config.yaml
"""
    )

    parser.add_argument(
        'image',
        help='ä¼šè®®ç›¸å…³å›¾ç‰‡è·¯å¾„ï¼ˆæ”¯æŒPNGã€JPGã€JPEGç­‰æ ¼å¼ï¼‰'
    )

    parser.add_argument(
        '-o', '--output',
        help='è¾“å‡ºé…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆé»˜è®¤è‡ªåŠ¨ç”Ÿæˆï¼‰'
    )

    parser.add_argument(
        '--generate-pdf',
        action='store_true',
        help='è‡ªåŠ¨ç”ŸæˆPDFæ–‡ä»¶'
    )

    parser.add_argument(
        '--no-open',
        action='store_true',
        help='ä¸è‡ªåŠ¨æ‰“å¼€ç”Ÿæˆçš„æ–‡ä»¶'
    )

    args = parser.parse_args()

    try:
        # åˆ›å»ºæå–å™¨
        extractor = MeetingImageExtractor()

        # å¤„ç†å›¾ç‰‡
        result = extractor.process_image(
            image_path=args.image,
            generate_pdf=args.generate_pdf,
            auto_open=not args.no_open
        )

        # è¾“å‡ºç»“æœ
        print("\n" + "=" * 60)
        print("âœ… å¤„ç†å®Œæˆ")
        print("=" * 60)

        if 'config_path' in result:
            print(f"ğŸ“‹ é…ç½®æ–‡ä»¶: {result['config_path']}")

        if 'markdown_path' in result:
            print(f"ğŸ“„ Markdown: {result['markdown_path']}")

        if 'pdf_path' in result:
            print(f"ğŸ“• PDFæ–‡ä»¶: {result['pdf_path']}")

        print("\nä¸‹ä¸€æ­¥:")
        if not args.generate_pdf and 'config_path' in result:
            print(f"  ç”Ÿæˆçºªè¦: python scripts/generate-meeting.py {result['config_path']}")
        if 'markdown_path' in result and not args.generate_pdf:
            print(f"  è½¬æ¢PDF: python run.py '{result['markdown_path']}'")

    except KeyboardInterrupt:
        print("\n\nâš ï¸  æ“ä½œå·²å–æ¶ˆ")
        sys.exit(1)
    except Exception as e:
        print(f"\nâŒ é”™è¯¯: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
